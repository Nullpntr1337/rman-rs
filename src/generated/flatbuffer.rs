#![allow(clippy::all, unused_imports)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rman {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum BundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bundle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bundle<'a> {
  type Inner = Bundle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bundle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bundle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BundleArgs<'args>
  ) -> flatbuffers::WIPOffset<Bundle<'bldr>> {
    let mut builder = BundleBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.chunks { builder.add_chunks(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Bundle::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk>>>>(Bundle::VT_CHUNKS, None)}
  }
}

impl flatbuffers::Verifiable for Bundle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Chunk>>>>("chunks", Self::VT_CHUNKS, false)?
     .finish();
    Ok(())
  }
}
pub struct BundleArgs<'a> {
    pub id: u64,
    pub chunks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>>>,
}
impl<'a> Default for BundleArgs<'a> {
  #[inline]
  fn default() -> Self {
    BundleArgs {
      id: 0,
      chunks: None,
    }
  }
}

pub struct BundleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BundleBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Bundle::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_chunks(&mut self, chunks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Chunk<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bundle::VT_CHUNKS, chunks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BundleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BundleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bundle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bundle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bundle");
      ds.field("id", &self.id());
      ds.field("chunks", &self.chunks());
      ds.finish()
  }
}
pub enum ChunkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Chunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chunk<'a> {
  type Inner = Chunk<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Chunk<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COMPRESSED_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_UNCOMPRESSED_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chunk { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChunkArgs
  ) -> flatbuffers::WIPOffset<Chunk<'bldr>> {
    let mut builder = ChunkBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_uncompressed_size(args.uncompressed_size);
    builder.add_compressed_size(args.compressed_size);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Chunk::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn compressed_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Chunk::VT_COMPRESSED_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uncompressed_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Chunk::VT_UNCOMPRESSED_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Chunk<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<u32>("compressed_size", Self::VT_COMPRESSED_SIZE, false)?
     .visit_field::<u32>("uncompressed_size", Self::VT_UNCOMPRESSED_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct ChunkArgs {
    pub id: u64,
    pub compressed_size: u32,
    pub uncompressed_size: u32,
}
impl<'a> Default for ChunkArgs {
  #[inline]
  fn default() -> Self {
    ChunkArgs {
      id: 0,
      compressed_size: 0,
      uncompressed_size: 0,
    }
  }
}

pub struct ChunkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChunkBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Chunk::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_compressed_size(&mut self, compressed_size: u32) {
    self.fbb_.push_slot::<u32>(Chunk::VT_COMPRESSED_SIZE, compressed_size, 0);
  }
  #[inline]
  pub fn add_uncompressed_size(&mut self, uncompressed_size: u32) {
    self.fbb_.push_slot::<u32>(Chunk::VT_UNCOMPRESSED_SIZE, uncompressed_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChunkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Chunk<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Chunk");
      ds.field("id", &self.id());
      ds.field("compressed_size", &self.compressed_size());
      ds.field("uncompressed_size", &self.uncompressed_size());
      ds.finish()
  }
}
pub enum DirectoryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Directory<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directory<'a> {
  type Inner = Directory<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Directory<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PARENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Directory { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DirectoryArgs<'args>
  ) -> flatbuffers::WIPOffset<Directory<'bldr>> {
    let mut builder = DirectoryBuilder::new(_fbb);
    builder.add_parent_id(args.parent_id);
    builder.add_id(args.id);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Directory::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn parent_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Directory::VT_PARENT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Directory::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Directory<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<u64>("parent_id", Self::VT_PARENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct DirectoryArgs<'a> {
    pub id: u64,
    pub parent_id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DirectoryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DirectoryArgs {
      id: 0,
      parent_id: 0,
      name: None,
    }
  }
}

pub struct DirectoryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectoryBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Directory::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_parent_id(&mut self, parent_id: u64) {
    self.fbb_.push_slot::<u64>(Directory::VT_PARENT_ID, parent_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directory::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectoryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectoryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directory<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Directory<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Directory");
      ds.field("id", &self.id());
      ds.field("parent_id", &self.parent_id());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum FileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct File<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for File<'a> {
  type Inner = File<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> File<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DIRECTORY_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_LANGUAGE_MASK: flatbuffers::VOffsetT = 12;
  pub const VT_UNK5: flatbuffers::VOffsetT = 14;
  pub const VT_UNK6: flatbuffers::VOffsetT = 16;
  pub const VT_CHUNK_IDS: flatbuffers::VOffsetT = 18;
  pub const VT_UNK8: flatbuffers::VOffsetT = 20;
  pub const VT_LINK: flatbuffers::VOffsetT = 22;
  pub const VT_UNK10: flatbuffers::VOffsetT = 24;
  pub const VT_PARAMS_INDEX: flatbuffers::VOffsetT = 26;
  pub const VT_PERMISSIONS: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    File { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FileArgs<'args>
  ) -> flatbuffers::WIPOffset<File<'bldr>> {
    let mut builder = FileBuilder::new(_fbb);
    builder.add_language_mask(args.language_mask);
    builder.add_directory_id(args.directory_id);
    builder.add_id(args.id);
    if let Some(x) = args.link { builder.add_link(x); }
    if let Some(x) = args.chunk_ids { builder.add_chunk_ids(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_size_(args.size_);
    builder.add_unk10(args.unk10);
    builder.add_permissions(args.permissions);
    builder.add_params_index(args.params_index);
    builder.add_unk8(args.unk8);
    builder.add_unk6(args.unk6);
    builder.add_unk5(args.unk5);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(File::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn directory_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(File::VT_DIRECTORY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(File::VT_SIZE_, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_NAME, None)}
  }
  #[inline]
  pub fn language_mask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(File::VT_LANGUAGE_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk5(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK5, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk6(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK6, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunk_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(File::VT_CHUNK_IDS, None)}
  }
  #[inline]
  pub fn unk8(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_LINK, None)}
  }
  #[inline]
  pub fn unk10(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(File::VT_UNK10, Some(0)).unwrap()}
  }
  #[inline]
  pub fn params_index(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_PARAMS_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn permissions(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_PERMISSIONS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for File<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<u64>("directory_id", Self::VT_DIRECTORY_ID, false)?
     .visit_field::<u32>("size_", Self::VT_SIZE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("language_mask", Self::VT_LANGUAGE_MASK, false)?
     .visit_field::<u8>("unk5", Self::VT_UNK5, false)?
     .visit_field::<u8>("unk6", Self::VT_UNK6, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("chunk_ids", Self::VT_CHUNK_IDS, false)?
     .visit_field::<u8>("unk8", Self::VT_UNK8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<u16>("unk10", Self::VT_UNK10, false)?
     .visit_field::<u8>("params_index", Self::VT_PARAMS_INDEX, false)?
     .visit_field::<u8>("permissions", Self::VT_PERMISSIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct FileArgs<'a> {
    pub id: u64,
    pub directory_id: u64,
    pub size_: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub language_mask: u64,
    pub unk5: u8,
    pub unk6: u8,
    pub chunk_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub unk8: u8,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk10: u16,
    pub params_index: u8,
    pub permissions: u8,
}
impl<'a> Default for FileArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileArgs {
      id: 0,
      directory_id: 0,
      size_: 0,
      name: None,
      language_mask: 0,
      unk5: 0,
      unk6: 0,
      chunk_ids: None,
      unk8: 0,
      link: None,
      unk10: 0,
      params_index: 0,
      permissions: 0,
    }
  }
}

pub struct FileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(File::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_directory_id(&mut self, directory_id: u64) {
    self.fbb_.push_slot::<u64>(File::VT_DIRECTORY_ID, directory_id, 0);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(File::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_NAME, name);
  }
  #[inline]
  pub fn add_language_mask(&mut self, language_mask: u64) {
    self.fbb_.push_slot::<u64>(File::VT_LANGUAGE_MASK, language_mask, 0);
  }
  #[inline]
  pub fn add_unk5(&mut self, unk5: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK5, unk5, 0);
  }
  #[inline]
  pub fn add_unk6(&mut self, unk6: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK6, unk6, 0);
  }
  #[inline]
  pub fn add_chunk_ids(&mut self, chunk_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_CHUNK_IDS, chunk_ids);
  }
  #[inline]
  pub fn add_unk8(&mut self, unk8: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK8, unk8, 0);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_LINK, link);
  }
  #[inline]
  pub fn add_unk10(&mut self, unk10: u16) {
    self.fbb_.push_slot::<u16>(File::VT_UNK10, unk10, 0);
  }
  #[inline]
  pub fn add_params_index(&mut self, params_index: u8) {
    self.fbb_.push_slot::<u8>(File::VT_PARAMS_INDEX, params_index, 0);
  }
  #[inline]
  pub fn add_permissions(&mut self, permissions: u8) {
    self.fbb_.push_slot::<u8>(File::VT_PERMISSIONS, permissions, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for File<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("File");
      ds.field("id", &self.id());
      ds.field("directory_id", &self.directory_id());
      ds.field("size_", &self.size_());
      ds.field("name", &self.name());
      ds.field("language_mask", &self.language_mask());
      ds.field("unk5", &self.unk5());
      ds.field("unk6", &self.unk6());
      ds.field("chunk_ids", &self.chunk_ids());
      ds.field("unk8", &self.unk8());
      ds.field("link", &self.link());
      ds.field("unk10", &self.unk10());
      ds.field("params_index", &self.params_index());
      ds.field("permissions", &self.permissions());
      ds.finish()
  }
}
pub enum KeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Key<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Key<'a> {
  type Inner = Key<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Key<'a> {
  pub const VT_UNK0: flatbuffers::VOffsetT = 4;
  pub const VT_UNK1: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Key { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args KeyArgs
  ) -> flatbuffers::WIPOffset<Key<'bldr>> {
    let mut builder = KeyBuilder::new(_fbb);
    builder.add_unk1(args.unk1);
    builder.add_unk0(args.unk0);
    builder.finish()
  }


  #[inline]
  pub fn unk0(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Key::VT_UNK0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Key::VT_UNK1, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Key<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("unk0", Self::VT_UNK0, false)?
     .visit_field::<u32>("unk1", Self::VT_UNK1, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyArgs {
    pub unk0: u16,
    pub unk1: u32,
}
impl<'a> Default for KeyArgs {
  #[inline]
  fn default() -> Self {
    KeyArgs {
      unk0: 0,
      unk1: 0,
    }
  }
}

pub struct KeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk0(&mut self, unk0: u16) {
    self.fbb_.push_slot::<u16>(Key::VT_UNK0, unk0, 0);
  }
  #[inline]
  pub fn add_unk1(&mut self, unk1: u32) {
    self.fbb_.push_slot::<u32>(Key::VT_UNK1, unk1, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Key<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Key<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Key");
      ds.field("unk0", &self.unk0());
      ds.field("unk1", &self.unk1());
      ds.finish()
  }
}
pub enum LanguageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Language<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Language<'a> {
  type Inner = Language<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Language<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Language { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LanguageArgs<'args>
  ) -> flatbuffers::WIPOffset<Language<'bldr>> {
    let mut builder = LanguageBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Language::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Language::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Language<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct LanguageArgs<'a> {
    pub id: u8,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LanguageArgs<'a> {
  #[inline]
  fn default() -> Self {
    LanguageArgs {
      id: 0,
      name: None,
    }
  }
}

pub struct LanguageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LanguageBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(Language::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Language::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LanguageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LanguageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Language<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Language<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Language");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum ManifestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Manifest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
  type Inner = Manifest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Manifest<'a> {
  pub const VT_BUNDLES: flatbuffers::VOffsetT = 4;
  pub const VT_LANGUAGES: flatbuffers::VOffsetT = 6;
  pub const VT_FILES: flatbuffers::VOffsetT = 8;
  pub const VT_DIRECTORIES: flatbuffers::VOffsetT = 10;
  pub const VT_KEYS: flatbuffers::VOffsetT = 12;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Manifest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ManifestArgs<'args>
  ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
    let mut builder = ManifestBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.keys { builder.add_keys(x); }
    if let Some(x) = args.directories { builder.add_directories(x); }
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.languages { builder.add_languages(x); }
    if let Some(x) = args.bundles { builder.add_bundles(x); }
    builder.finish()
  }


  #[inline]
  pub fn bundles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle>>>>(Manifest::VT_BUNDLES, None)}
  }
  #[inline]
  pub fn languages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Language<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Language>>>>(Manifest::VT_LANGUAGES, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File>>>>(Manifest::VT_FILES, None)}
  }
  #[inline]
  pub fn directories(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory>>>>(Manifest::VT_DIRECTORIES, None)}
  }
  #[inline]
  pub fn keys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key>>>>(Manifest::VT_KEYS, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param>>>>(Manifest::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for Manifest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Bundle>>>>("bundles", Self::VT_BUNDLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Language>>>>("languages", Self::VT_LANGUAGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<File>>>>("files", Self::VT_FILES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Directory>>>>("directories", Self::VT_DIRECTORIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Key>>>>("keys", Self::VT_KEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ManifestArgs<'a> {
    pub bundles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle<'a>>>>>,
    pub languages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Language<'a>>>>>,
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>>,
    pub directories: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory<'a>>>>>,
    pub keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>>>,
}
impl<'a> Default for ManifestArgs<'a> {
  #[inline]
  fn default() -> Self {
    ManifestArgs {
      bundles: None,
      languages: None,
      files: None,
      directories: None,
      keys: None,
      params: None,
    }
  }
}

pub struct ManifestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ManifestBuilder<'a, 'b> {
  #[inline]
  pub fn add_bundles(&mut self, bundles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bundle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_BUNDLES, bundles);
  }
  #[inline]
  pub fn add_languages(&mut self, languages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Language<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_LANGUAGES, languages);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<File<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_FILES, files);
  }
  #[inline]
  pub fn add_directories(&mut self, directories: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directory<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_DIRECTORIES, directories);
  }
  #[inline]
  pub fn add_keys(&mut self, keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Key<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_KEYS, keys);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Param<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ManifestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ManifestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Manifest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Manifest");
      ds.field("bundles", &self.bundles());
      ds.field("languages", &self.languages());
      ds.field("files", &self.files());
      ds.field("directories", &self.directories());
      ds.field("keys", &self.keys());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum ParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Param<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Param<'a> {
  type Inner = Param<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Param<'a> {
  pub const VT_UNK0: flatbuffers::VOffsetT = 4;
  pub const VT_HASH_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_UNK2: flatbuffers::VOffsetT = 8;
  pub const VT_UNK3: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_UNCOMPRESSED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Param { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ParamArgs
  ) -> flatbuffers::WIPOffset<Param<'bldr>> {
    let mut builder = ParamBuilder::new(_fbb);
    builder.add_max_uncompressed(args.max_uncompressed);
    builder.add_unk3(args.unk3);
    builder.add_unk2(args.unk2);
    builder.add_unk0(args.unk0);
    builder.add_hash_type(args.hash_type);
    builder.finish()
  }


  #[inline]
  pub fn unk0(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Param::VT_UNK0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hash_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Param::VT_HASH_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk2(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_UNK2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk3(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_UNK3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_uncompressed(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_MAX_UNCOMPRESSED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Param<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("unk0", Self::VT_UNK0, false)?
     .visit_field::<u8>("hash_type", Self::VT_HASH_TYPE, false)?
     .visit_field::<u32>("unk2", Self::VT_UNK2, false)?
     .visit_field::<u32>("unk3", Self::VT_UNK3, false)?
     .visit_field::<u32>("max_uncompressed", Self::VT_MAX_UNCOMPRESSED, false)?
     .finish();
    Ok(())
  }
}
pub struct ParamArgs {
    pub unk0: u16,
    pub hash_type: u8,
    pub unk2: u32,
    pub unk3: u32,
    pub max_uncompressed: u32,
}
impl<'a> Default for ParamArgs {
  #[inline]
  fn default() -> Self {
    ParamArgs {
      unk0: 0,
      hash_type: 0,
      unk2: 0,
      unk3: 0,
      max_uncompressed: 0,
    }
  }
}

pub struct ParamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ParamBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk0(&mut self, unk0: u16) {
    self.fbb_.push_slot::<u16>(Param::VT_UNK0, unk0, 0);
  }
  #[inline]
  pub fn add_hash_type(&mut self, hash_type: u8) {
    self.fbb_.push_slot::<u8>(Param::VT_HASH_TYPE, hash_type, 0);
  }
  #[inline]
  pub fn add_unk2(&mut self, unk2: u32) {
    self.fbb_.push_slot::<u32>(Param::VT_UNK2, unk2, 0);
  }
  #[inline]
  pub fn add_unk3(&mut self, unk3: u32) {
    self.fbb_.push_slot::<u32>(Param::VT_UNK3, unk3, 0);
  }
  #[inline]
  pub fn add_max_uncompressed(&mut self, max_uncompressed: u32) {
    self.fbb_.push_slot::<u32>(Param::VT_MAX_UNCOMPRESSED, max_uncompressed, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ParamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Param<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Param<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Param");
      ds.field("unk0", &self.unk0());
      ds.field("hash_type", &self.hash_type());
      ds.field("unk2", &self.unk2());
      ds.field("unk3", &self.unk3());
      ds.field("max_uncompressed", &self.max_uncompressed());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Manifest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn root_as_manifest(buf: &[u8]) -> Result<Manifest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Manifest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Manifest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_manifest_unchecked`.
pub fn size_prefixed_root_as_manifest(buf: &[u8]) -> Result<Manifest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Manifest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Manifest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn root_as_manifest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Manifest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Manifest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Manifest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn size_prefixed_root_as_manifest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Manifest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Manifest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Manifest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Manifest`.
pub unsafe fn root_as_manifest_unchecked(buf: &[u8]) -> Manifest {
  flatbuffers::root_unchecked::<Manifest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Manifest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Manifest`.
pub unsafe fn size_prefixed_root_as_manifest_unchecked(buf: &[u8]) -> Manifest {
  flatbuffers::size_prefixed_root_unchecked::<Manifest>(buf)
}
#[inline]
pub fn finish_manifest_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_manifest_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod rman

